<canvas id="artifactCanvas" myattr="myattr" style="display: block; position: absolute;top: 0%;left: 0%;z-index:0; cursor: move;">
</canvas>

<script type="module">
    import * as THREE from "https://cdn.skypack.dev/three@0.136.0";
    import {
      OrbitControls
    } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls";
    import {
      STLLoader
    } from "https://cdn.skypack.dev/three@0.136.0/examples/jsm/loaders/STLLoader";

    let intersect
    let type_select = "vertice";
    let objs = [];
    let mesh;
    window.mesh = mesh

    var scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);
    var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.setScalar(7);
    let renderer = new THREE.WebGLRenderer({
      antialias: true, canvas: artifactCanvas
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    window.addEventListener("resize", onWindowResize, true);
    document.body.appendChild(renderer.domElement);

    var controls = new OrbitControls(camera, renderer.domElement);
    let mesh_selector = document.getElementById('mesh_file')
    let file_name_field = document.getElementById('file_name')
    let path = mesh_selector.value

    var loader = new STLLoader();
    loader.load(document.URL.split('/builder')[0] + '{{ url_for("configure_bp.send", builder=builder, file="TMP")}}/'.replace('TMP', path), function(geometry) {
      var material = new THREE.MeshBasicMaterial({
        color: "gray"
      });
      console.log(path)
      file_name_field.value = path.split('.')[0].replaceAll('_', ' ').toProperCase()
      mesh = new THREE.Mesh(geometry, material);
      mesh.renderOrder = -1

      //mesh.rotation.set(0, Math.PI, 0);
      //mesh.scale.setScalar(10);
      scene.add(mesh);
      objs.push(mesh);
      window.mesh = mesh


      var wireframe = new THREE.LineSegments(new THREE.WireframeGeometry(geometry), new THREE.LineBasicMaterial({
        color: "aqua"
      }));
      mesh.add(wireframe);
      mesh.geometry.computeBoundingSphere()
      controls.target.copy(mesh.geometry.boundingSphere.center)
      controls.update()
    });

    var marker = new THREE.Mesh(new THREE.SphereBufferGeometry(0.25, 4, 2), new THREE.MeshBasicMaterial({
      color: 0xFFc8FF
    }));
    marker.position.setScalar(1);
    scene.add(marker);

    var intscs = [];
    var rc = new THREE.Raycaster();
    var m = new THREE.Vector2();
    var poi = new THREE.Vector3();
    var pos = new THREE.Vector3();
    var tp = [
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ];
    var tri = new THREE.Triangle();
    var bc = new THREE.Vector3();
    var idx = 0;

    renderer.domElement.addEventListener("pointermove", onMouseMove);

    document.getElementById("vertice").addEventListener("click", function (){
        type_select = "vertice"
        scene.remove( line );
        renderer.domElement.removeEventListener("dblclick", selectFace);
        renderer.domElement.addEventListener("dblclick", select_vertice);
    })
    document.getElementById("face").addEventListener("click", function (){
        type_select = "face"
        console.log(type_select)
        scene.add( line );
        renderer.domElement.removeEventListener("dblclick", select_vertice);
        renderer.domElement.addEventListener("dblclick", selectFace);
    })


    let line, raycaster;
    let geometry = new THREE.BufferGeometry();
    geometry.setAttribute( 'position', new THREE.BufferAttribute( new Float32Array( 4 * 3 ), 3 ) );

    let material = new THREE.MeshBasicMaterial( { color: "red"} );

    line = new THREE.Mesh( geometry, material );
    line.renderOrder = 0;

    scene.add( line );
    raycaster = new THREE.Raycaster();

    function selectFace(event) {
        raycaster.setFromCamera( m, camera );
        m.x = (event.clientX / window.innerWidth) * 2 - 1;
        m.y = -(event.clientY / window.innerHeight) * 2 + 1;
        console.log(mesh)
        let intersects = raycaster.intersectObject( mesh );
        window.intersects = intersects

        for (var i = 0; i < intersects.length; i++) {
            if (intersects[i].faceIndex){
                intersect = intersects[i]
                let field_marker = document.getElementById(window.current_marker);
                field_marker.value = "'face: " + intersect.faceIndex.toString() + "'"
                break
            }
        }

        if ( intersects.length > 0 ) {

            //let intersect = intersects[ 0 ];
            let face = intersect.face;

            let linePosition = line.geometry.attributes.position;
            let meshPosition = mesh.geometry.attributes.position;

            linePosition.copyAt( 0, meshPosition, face.a );
            linePosition.copyAt( 1, meshPosition, face.b );
            linePosition.copyAt( 2, meshPosition, face.c );
            linePosition.copyAt( 3, meshPosition, face.a );

            mesh.updateMatrix();

            line.geometry.applyMatrix4( mesh.matrix );
            console.log(line)

            line.visible = true;
            console.log('true')
        } else {

            line.visible = false;

        }
    }
    function onMouseMove(event) {
      m.x = (event.clientX / window.innerWidth) * 2 - 1;
      m.y = -(event.clientY / window.innerHeight) * 2 + 1;
      rc.setFromCamera(m, camera);
      intscs = rc.intersectObjects(objs, false);
      if (intscs.length > 0) {
        let o = intscs[0];
        console.log(o)
        poi.copy(o.point);
        o.object.worldToLocal(poi);
        setPos(o.faceIndex);
        o.object.localToWorld(pos);
        marker.position.copy(pos);
      }
    }


    function select_vertice(event) {
        console.log(type_select)
        console.log(event)
        if (type_select === "vertice") {
            let field_marker = document.getElementById(window.current_marker);
            let field_value = field_marker.value
            if (field_value === ''){
                field_marker.value = marker.position.toArray().toString()
            }
            else {
                field_marker.value = field_value + "], [" + marker.position.toArray().toString()
            }
        }
    }


    function setPos(faceIndex) {
      tp[0].fromBufferAttribute(intscs[0].object.geometry.attributes.position, faceIndex * 3 + 0);
      tp[1].fromBufferAttribute(intscs[0].object.geometry.attributes.position, faceIndex * 3 + 1);
      tp[2].fromBufferAttribute(intscs[0].object.geometry.attributes.position, faceIndex * 3 + 2);
      tri.set(tp[0], tp[1], tp[2]);
      tri.getBarycoord(poi, bc);
      if (bc.x > bc.y && bc.x > bc.z) {
        idx = 0;
      } else if (bc.y > bc.x && bc.y > bc.z) {
        idx = 1;
      } else if (bc.z > bc.x && bc.z > bc.y) {
        idx = 2;
      }
      pos.copy(tp[idx]);
    }
    String.prototype.toProperCase = function () {
        return this.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
    };
    function upload_file(){
        path = mesh_selector.value
        objs = [];
        while (scene.children.length)
        {
            scene.remove(scene.children[0]);
        }
        scene.add(marker);
        scene.add(line);
        file_name_field.value = path.split('.')[0].replaceAll('_', ' ').toProperCase()
        loader.load(document.URL.split('/builder')[0] + '{{ url_for("configure_bp.send", builder=builder, file="TMP")}}/'.replace('TMP', path), function(geometry) {
            var material = new THREE.MeshBasicMaterial({
                color: "gray"
            });
            scene.remove(mesh)
            mesh = new THREE.Mesh(geometry, material);
            mesh.renderOrder = -1
            scene.add(mesh);
            objs.push(mesh);
            //window.mesh = mesh


            var wireframe = new THREE.LineSegments(new THREE.WireframeGeometry(geometry), new THREE.LineBasicMaterial({
            color: "aqua"
            }));
            mesh.add(wireframe);
            mesh.geometry.computeBoundingSphere()
            controls.target.copy(mesh.geometry.boundingSphere.center)
            controls.update()
            });
    }

    mesh_selector.addEventListener("change", upload_file);

    renderer.setAnimationLoop(() => {
      renderer.render(scene, camera);
    });
    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.render(scene, camera);
    }
</script>

<script>
    {% for node in nodes %}
    form_{{ node }} = document.getElementById("marker_{{ node }}");
    form_{{ node }}.onclick = function() {
        form_{{ node }}.value = ''
        window.current_marker = "marker_{{ node }}";
    };
    {% endfor %}
</script>